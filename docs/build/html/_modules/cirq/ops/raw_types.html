<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>cirq.ops.raw_types &mdash; fd-greens 0.0.1 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> fd-greens
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">fd-greens</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">fd-greens</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>cirq.ops.raw_types</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for cirq.ops.raw_types</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2018 The Cirq Developers</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;Basic types defining qubits, gates, and operations.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AbstractSet</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Collection</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">cirq</span> <span class="kn">import</span> <span class="n">protocols</span><span class="p">,</span> <span class="n">value</span>
<span class="kn">from</span> <span class="nn">cirq.type_workarounds</span> <span class="kn">import</span> <span class="n">NotImplementedType</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cirq</span>


<span class="k">class</span> <span class="nc">Qid</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Identifies a quantum object such as a qubit, qudit, resonator, etc.</span>

<span class="sd">    Child classes represent specific types of objects, such as a qubit at a</span>
<span class="sd">    particular location on a chip or a qubit with a particular name.</span>

<span class="sd">    The main criteria that a custom qid must satisfy is *comparability*. Child</span>
<span class="sd">    classes meet this criteria by implementing the `_comparison_key` method. For</span>
<span class="sd">    example, `cirq.LineQubit`&#39;s `_comparison_key` method returns `self.x`. This</span>
<span class="sd">    ensures that line qubits with the same `x` are equal, and that line qubits</span>
<span class="sd">    will be sorted ascending by `x`. `Qid` implements all equality,</span>
<span class="sd">    comparison, and hashing methods via `_comparison_key`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_comparison_key</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a value used to sort and compare this qubit with others.</span>

<span class="sd">        By default, qubits of differing type are sorted ascending according to</span>
<span class="sd">        their type name. Qubits of the same type are then sorted using their</span>
<span class="sd">        comparison key.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the dimension or the number of quantum levels this qid has.</span>
<span class="sd">        E.g. 2 for a qubit, 3 for a qutrit, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">validate_dimension</span><span class="p">(</span><span class="n">dimension</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Raises an exception if `dimension` is not positive.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: `dimension` is not positive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Wrong qid dimension. Expected a positive integer but got </span><span class="si">{</span><span class="n">dimension</span><span class="si">}</span><span class="s1">.&#39;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">with_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Qid&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a new qid with a different dimension.</span>

<span class="sd">        Child classes can override.  Wraps the qubit object by default.</span>

<span class="sd">        Args:</span>
<span class="sd">            dimension: The new dimension or number of levels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">_QubitAsQid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cmp_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comparison_key</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="n">Qid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comparison_key</span><span class="p">()))</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Qid</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmp_tuple</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_cmp_tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Qid</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmp_tuple</span><span class="p">()</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_cmp_tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Qid</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmp_tuple</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_cmp_tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Qid</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmp_tuple</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_cmp_tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Qid</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmp_tuple</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">_cmp_tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Qid</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cmp_tuple</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">_cmp_tuple</span><span class="p">()</span>


<span class="nd">@functools</span><span class="o">.</span><span class="n">total_ordering</span>
<span class="k">class</span> <span class="nc">_QubitAsQid</span><span class="p">(</span><span class="n">Qid</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubit</span><span class="p">:</span> <span class="n">Qid</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qubit</span> <span class="o">=</span> <span class="n">qubit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span> <span class="o">=</span> <span class="n">dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validate_dimension</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">qubit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qid</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qubit</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span>

    <span class="k">def</span> <span class="nf">with_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Qid</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a copy with a different dimension or number of levels.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="o">.</span><span class="n">with_dimension</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_comparison_key</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="c1"># Don&#39;t include self._qubit.dimension</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qubit</span><span class="o">.</span><span class="n">_cmp_tuple</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="si">!r}</span><span class="s1">.with_dimension(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="si">}</span><span class="s1">)&#39;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">qubit</span><span class="si">!s}</span><span class="s1"> (d=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="si">}</span><span class="s1">)&#39;</span>

    <span class="k">def</span> <span class="nf">_json_dict_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">obj_to_dict_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;qubit&#39;</span><span class="p">,</span> <span class="s1">&#39;dimension&#39;</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">Gate</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="n">ABCMetaImplementAnyOneOf</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An operation type that can be applied to a collection of qubits.</span>

<span class="sd">    Gates can be applied to qubits by calling their on() method with</span>
<span class="sd">    the qubits to be applied to supplied, or, alternatively, by simply</span>
<span class="sd">    calling the gate on the qubits.  In other words calling MyGate.on(q1, q2)</span>
<span class="sd">    to create an Operation on q1 and q2 is equivalent to MyGate(q1,q2).</span>

<span class="sd">    Gates operate on a certain number of qubits. All implementations of gate</span>
<span class="sd">    must implement the `num_qubits` method declaring how many qubits they</span>
<span class="sd">    act on. The gate feature classes `SingleQubitGate` and `TwoQubitGate`</span>
<span class="sd">    can be used to avoid writing this boilerplate.</span>

<span class="sd">    Linear combinations of gates can be created by adding gates together and</span>
<span class="sd">    multiplying them by scalars.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">validate_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubits</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="s1">&#39;cirq.Qid&#39;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Checks if this gate can be applied to the given qubits.</span>

<span class="sd">        By default checks that:</span>
<span class="sd">        - inputs are of type `Qid`</span>
<span class="sd">        - len(qubits) == num_qubits()</span>
<span class="sd">        - qubit_i.dimension == qid_shape[i] for all qubits</span>

<span class="sd">        Child classes can override.  The child implementation should call</span>
<span class="sd">        `super().validate_args(qubits)` then do custom checks.</span>

<span class="sd">        Args:</span>
<span class="sd">            qubits: The sequence of qubits to potentially apply the gate to.</span>

<span class="sd">        Throws:</span>
<span class="sd">            ValueError: The gate can&#39;t be applied to the qubits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_validate_qid_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubits</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">qubits</span><span class="p">:</span> <span class="n">Qid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Operation&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns an application of this gate to the given qubits.</span>

<span class="sd">        Args:</span>
<span class="sd">            *qubits: The collection of qubits to potentially apply the gate to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Avoids circular import.</span>
        <span class="kn">from</span> <span class="nn">cirq.ops</span> <span class="kn">import</span> <span class="n">gate_operation</span>

        <span class="k">return</span> <span class="n">gate_operation</span><span class="o">.</span><span class="n">GateOperation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">qubits</span><span class="p">))</span>

    <span class="c1"># TODO(#3388) Add documentation for Raises.</span>
    <span class="c1"># pylint: disable=missing-raises-doc</span>
    <span class="k">def</span> <span class="nf">on_each</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">targets</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Qid</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;cirq.Operation&#39;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of operations applying the gate to all targets.</span>

<span class="sd">        Args:</span>
<span class="sd">            *targets: The qubits to apply this gate to. For single-qubit gates</span>
<span class="sd">            this can be provided as varargs or a combination of nested</span>
<span class="sd">            iterables. For multi-qubit gates this must be provided as an</span>
<span class="sd">            `Iterable[Sequence[Qid]]`, where each sequence has `num_qubits`</span>
<span class="sd">            qubits.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Operations applying this gate to the target qubits.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If targets are not instances of Qid or Iterable[Qid].</span>
<span class="sd">                If the gate qubit number is incompatible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">operations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;cirq.Operation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_qubits_</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">iterator</span><span class="p">:</span> <span class="n">Iterable</span> <span class="o">=</span> <span class="n">targets</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">targets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">targets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> object is not iterable.&#39;</span><span class="p">)</span>
                <span class="n">t0</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">targets</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">iterator</span> <span class="o">=</span> <span class="p">[</span><span class="n">t0</span><span class="p">]</span> <span class="k">if</span> <span class="n">t0</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Qid</span><span class="p">)</span> <span class="k">else</span> <span class="n">t0</span>
            <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Inputs to multi-qubit gates must be Sequence[Qid].&#39;</span>
                        <span class="sa">f</span><span class="s1">&#39; Type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Qid</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">target</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;All values in sequence should be Qids, but got </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_qubits_</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Expected </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_qubits_</span><span class="p">()</span><span class="si">}</span><span class="s1"> qubits, got </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">operations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="o">*</span><span class="n">target</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">operations</span>

        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">Qid</span><span class="p">):</span>
                <span class="n">operations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">operations</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_each</span><span class="p">(</span><span class="o">*</span><span class="n">target</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Gate was called with type different than Qid. Type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">operations</span>

    <span class="c1"># pylint: enable=missing-raises-doc</span>
    <span class="k">def</span> <span class="nf">wrap_in_linear_combination</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">complex</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;cirq.LinearCombinationOfGates&#39;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">cirq.ops</span> <span class="kn">import</span> <span class="n">linear_combinations</span>

        <span class="k">return</span> <span class="n">linear_combinations</span><span class="o">.</span><span class="n">LinearCombinationOfGates</span><span class="p">({</span><span class="bp">self</span><span class="p">:</span> <span class="n">coefficient</span><span class="p">})</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;Gate&#39;</span><span class="p">,</span> <span class="s1">&#39;cirq.LinearCombinationOfGates&#39;</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;cirq.LinearCombinationOfGates&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Gate</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap_in_linear_combination</span><span class="p">()</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">wrap_in_linear_combination</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap_in_linear_combination</span><span class="p">()</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;Gate&#39;</span><span class="p">,</span> <span class="s1">&#39;cirq.LinearCombinationOfGates&#39;</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;cirq.LinearCombinationOfGates&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Gate</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap_in_linear_combination</span><span class="p">()</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">wrap_in_linear_combination</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap_in_linear_combination</span><span class="p">()</span> <span class="o">-</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;cirq.LinearCombinationOfGates&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap_in_linear_combination</span><span class="p">(</span><span class="n">coefficient</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">complex</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;cirq.LinearCombinationOfGates&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap_in_linear_combination</span><span class="p">(</span><span class="n">coefficient</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">complex</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;cirq.LinearCombinationOfGates&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap_in_linear_combination</span><span class="p">(</span><span class="n">coefficient</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">complex</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;cirq.LinearCombinationOfGates&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap_in_linear_combination</span><span class="p">(</span><span class="n">coefficient</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">power</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">power</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">power</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># HACK: break cycle</span>
            <span class="kn">from</span> <span class="nn">cirq.devices</span> <span class="kn">import</span> <span class="n">line_qubit</span>

            <span class="n">decomposed</span> <span class="o">=</span> <span class="n">protocols</span><span class="o">.</span><span class="n">decompose_once_with_qubits</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">qubits</span><span class="o">=</span><span class="n">line_qubit</span><span class="o">.</span><span class="n">LineQid</span><span class="o">.</span><span class="n">for_gate</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">decomposed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

            <span class="n">inverse_decomposed</span> <span class="o">=</span> <span class="n">protocols</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">decomposed</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">inverse_decomposed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

            <span class="k">return</span> <span class="n">_InverseCompositeGate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">with_probability</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">probability</span><span class="p">:</span> <span class="s1">&#39;cirq.TParamVal&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;cirq.Gate&#39;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">cirq.ops.random_gate_channel</span> <span class="kn">import</span> <span class="n">RandomGateChannel</span>

        <span class="k">if</span> <span class="n">probability</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">RandomGateChannel</span><span class="p">(</span><span class="n">sub_gate</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span><span class="n">probability</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">controlled</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_controls</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">control_values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Collection</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">control_qid_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Gate&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a controlled version of this gate. If no arguments are</span>
<span class="sd">        specified, defaults to a single qubit control.</span>

<span class="sd">         num_controls: Total number of control qubits.</span>
<span class="sd">         control_values: For which control qubit values to apply the sub</span>
<span class="sd">             gate.  A sequence of length `num_controls` where each</span>
<span class="sd">             entry is an integer (or set of integers) corresponding to the</span>
<span class="sd">             qubit value (or set of possible values) where that control is</span>
<span class="sd">             enabled.  When all controls are enabled, the sub gate is</span>
<span class="sd">             applied.  If unspecified, control values default to 1.</span>
<span class="sd">         control_qid_shape: The qid shape of the controls.  A tuple of the</span>
<span class="sd">             expected dimension of each control qid.  Defaults to</span>
<span class="sd">             `(2,) * num_controls`.  Specify this argument when using qudits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Avoids circular import.</span>
        <span class="kn">from</span> <span class="nn">cirq.ops</span> <span class="kn">import</span> <span class="n">ControlledGate</span>

        <span class="k">if</span> <span class="n">num_controls</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">ControlledGate</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">num_controls</span><span class="o">=</span><span class="n">num_controls</span><span class="p">,</span>
            <span class="n">control_values</span><span class="o">=</span><span class="n">control_values</span><span class="p">,</span>
            <span class="n">control_qid_shape</span><span class="o">=</span><span class="n">control_qid_shape</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># num_qubits, _num_qubits_, and _qid_shape_ are implemented with alternative</span>
    <span class="c1"># to keep backwards compatibility with versions of cirq where num_qubits</span>
    <span class="c1"># is an abstract method.</span>
    <span class="k">def</span> <span class="nf">_backwards_compatibility_num_qubits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">num_qubits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_has_stabilizer_effect_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="nd">@value</span><span class="o">.</span><span class="n">alternative</span><span class="p">(</span><span class="n">requires</span><span class="o">=</span><span class="s1">&#39;_num_qubits_&#39;</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">_backwards_compatibility_num_qubits</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">num_qubits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The number of qubits this gate acts on.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_num_qubits_from_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qid_shape_</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_num_qubits_proto_from_num_qubits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_qubits</span><span class="p">()</span>

    <span class="nd">@value</span><span class="o">.</span><span class="n">alternative</span><span class="p">(</span><span class="n">requires</span><span class="o">=</span><span class="s1">&#39;num_qubits&#39;</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">_num_qubits_proto_from_num_qubits</span><span class="p">)</span>
    <span class="nd">@value</span><span class="o">.</span><span class="n">alternative</span><span class="p">(</span><span class="n">requires</span><span class="o">=</span><span class="s1">&#39;_qid_shape_&#39;</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">_num_qubits_from_shape</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_num_qubits_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The number of qubits this gate acts on.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_default_shape_from_num_qubits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="n">num_qubits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_qubits_</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">num_qubits</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">2</span><span class="p">,)</span> <span class="o">*</span> <span class="n">num_qubits</span>

    <span class="nd">@value</span><span class="o">.</span><span class="n">alternative</span><span class="p">(</span><span class="n">requires</span><span class="o">=</span><span class="s1">&#39;_num_qubits_&#39;</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="n">_default_shape_from_num_qubits</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_qid_shape_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns a Tuple containing the number of quantum levels of each qid</span>
<span class="sd">        the gate acts on.  E.g. (2, 2, 2) for the three-qubit CCZ gate and</span>
<span class="sd">        (3, 3) for a 2-qutrit ternary gate.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_commutes_on_qids_</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">qids</span><span class="p">:</span> <span class="s1">&#39;Sequence[cirq.Qid]&#39;</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">NotImplementedType</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">_commutes_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">NotImplementedType</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Gate</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">if</span> <span class="n">protocols</span><span class="o">.</span><span class="n">qid_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="n">protocols</span><span class="o">.</span><span class="n">qid_shape</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># HACK: break cycle</span>
        <span class="kn">from</span> <span class="nn">cirq.devices</span> <span class="kn">import</span> <span class="n">line_qubit</span>

        <span class="n">qs</span> <span class="o">=</span> <span class="n">line_qubit</span><span class="o">.</span><span class="n">LineQid</span><span class="o">.</span><span class="n">for_qid_shape</span><span class="p">(</span><span class="n">protocols</span><span class="o">.</span><span class="n">qid_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">commutes</span><span class="p">(</span><span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">qs</span><span class="p">),</span> <span class="n">other</span><span class="p">(</span><span class="o">*</span><span class="n">qs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_mul_with_qubits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubits</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;cirq.Qid&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;cirq.GateOperation.__mul__ delegates to this method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">_rmul_with_qubits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubits</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;cirq.Qid&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;cirq.GateOperation.__rmul__ delegates to this method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">_json_dict_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">obj_to_dict_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute_names</span><span class="o">=</span><span class="p">[])</span>


<span class="n">TSelf</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;TSelf&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s1">&#39;Operation&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Operation</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An effect applied to a collection of qubits.</span>

<span class="sd">    The most common kind of Operation is a GateOperation, which separates its</span>
<span class="sd">    effect into a qubit-independent Gate and the qubits it should be applied to.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;cirq.Gate&#39;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">qubits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;cirq.Qid&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_num_qubits_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The number of qubits this operation acts on.</span>

<span class="sd">        By definition, returns the length of `qubits`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_qid_shape_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">qid_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">)</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">with_qubits</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">TSelf</span><span class="p">,</span> <span class="o">*</span><span class="n">new_qubits</span><span class="p">:</span> <span class="s1">&#39;cirq.Qid&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TSelf</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the same operation, but applied to different qubits.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_qubits: The new qubits to apply the operation to. The order must</span>
<span class="sd">                exactly match the order of qubits returned from the operation&#39;s</span>
<span class="sd">                `qubits` property.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tags</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns a tuple of the operation&#39;s tags.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">untagged</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;cirq.Operation&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the underlying operation without any tags.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">with_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">new_tags</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;cirq.Operation&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates a new TaggedOperation, with this op and the specified tags.</span>

<span class="sd">        This method can be used to attach meta-data to specific operations</span>
<span class="sd">        without affecting their functionality.  The intended usage is to</span>
<span class="sd">        attach classes intended for this purpose or strings to mark operations</span>
<span class="sd">        for specific usage that will be recognized by consumers.  Specific</span>
<span class="sd">        examples include ignoring this operation in optimization passes,</span>
<span class="sd">        hardware-specific functionality, or circuit diagram customizability.</span>

<span class="sd">        Tags can be a list of any type of object that is useful to identify</span>
<span class="sd">        this operation as long as the type is hashable.  If you wish the</span>
<span class="sd">        resulting operation to be eventually serialized into JSON, you should</span>
<span class="sd">        also restrict the operation to be JSON serializable.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_tags: The tags to wrap this operation in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">new_tags</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">TaggedOperation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">new_tags</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform_qubits</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">TSelf</span><span class="p">,</span>
        <span class="n">qubit_map</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="s1">&#39;cirq.Qid&#39;</span><span class="p">,</span> <span class="s1">&#39;cirq.Qid&#39;</span><span class="p">],</span> <span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;cirq.Qid&#39;</span><span class="p">],</span> <span class="s1">&#39;cirq.Qid&#39;</span><span class="p">]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TSelf</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the same operation, but with different qubits.</span>

<span class="sd">        Args:</span>
<span class="sd">            qubit_map: A function or a dict mapping each current qubit into a desired</span>
<span class="sd">                new qubit.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The receiving operation but with qubits transformed by the given</span>
<span class="sd">                function.</span>
<span class="sd">        Raises:</span>
<span class="sd">            TypeError: qubit_map was not a function or dict mapping qubits to</span>
<span class="sd">                qubits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">qubit_map</span><span class="p">):</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">qubit_map</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qubit_map</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">q</span><span class="p">:</span> <span class="n">qubit_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;qubit_map must be a function or dict mapping qubits to qubits.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_qubits</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">transform</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">controlled_by</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">control_qubits</span><span class="p">:</span> <span class="s1">&#39;cirq.Qid&#39;</span><span class="p">,</span>
        <span class="n">control_values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Collection</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;cirq.Operation&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns a controlled version of this operation. If no control_qubits</span>
<span class="sd">           are specified, returns self.</span>

<span class="sd">        Args:</span>
<span class="sd">            control_qubits: Qubits to control the operation by. Required.</span>
<span class="sd">            control_values: For which control qubit values to apply the</span>
<span class="sd">                operation.  A sequence of the same length as `control_qubits`</span>
<span class="sd">                where each entry is an integer (or set of integers)</span>
<span class="sd">                corresponding to the qubit value (or set of possible values)</span>
<span class="sd">                where that control is enabled.  When all controls are enabled,</span>
<span class="sd">                the operation is applied.  If unspecified, control values</span>
<span class="sd">                default to 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Avoids circular import.</span>
        <span class="kn">from</span> <span class="nn">cirq.ops.controlled_operation</span> <span class="kn">import</span> <span class="n">ControlledOperation</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">control_qubits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">ControlledOperation</span><span class="p">(</span><span class="n">control_qubits</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">control_values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">with_probability</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">probability</span><span class="p">:</span> <span class="s1">&#39;cirq.TParamVal&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;cirq.Operation&#39;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">cirq.ops.random_gate_channel</span> <span class="kn">import</span> <span class="n">RandomGateChannel</span>

        <span class="n">gate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gate</span>
        <span class="k">if</span> <span class="n">gate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;with_probability on gateless operation.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">probability</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">RandomGateChannel</span><span class="p">(</span><span class="n">sub_gate</span><span class="o">=</span><span class="n">gate</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span><span class="n">probability</span><span class="p">)</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">validate_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubits</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="s1">&#39;cirq.Qid&#39;</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Raises an exception if the `qubits` don&#39;t match this operation&#39;s qid</span>
<span class="sd">        shape.</span>

<span class="sd">        Call this method from a subclass&#39;s `with_qubits` method.</span>

<span class="sd">        Args:</span>
<span class="sd">            qubits: The new qids for the operation.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: The operation had qids that don&#39;t match it&#39;s qid shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_validate_qid_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubits</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_commutes_</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">atol</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-8</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">NotImplementedType</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Determine if this Operation commutes with the object&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;qubits&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">)</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">qubits</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="kn">from</span> <span class="nn">cirq</span> <span class="kn">import</span> <span class="n">circuits</span>

        <span class="n">circuit12</span> <span class="o">=</span> <span class="n">circuits</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="n">circuit21</span> <span class="o">=</span> <span class="n">circuits</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Don&#39;t create gigantic matrices.</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">protocols</span><span class="o">.</span><span class="n">qid_shape_protocol</span><span class="o">.</span><span class="n">qid_shape</span><span class="p">(</span><span class="n">circuit12</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">10</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>  <span class="c1"># coverage: ignore</span>

        <span class="n">m12</span> <span class="o">=</span> <span class="n">protocols</span><span class="o">.</span><span class="n">unitary_protocol</span><span class="o">.</span><span class="n">unitary</span><span class="p">(</span><span class="n">circuit12</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">m21</span> <span class="o">=</span> <span class="n">protocols</span><span class="o">.</span><span class="n">unitary_protocol</span><span class="o">.</span><span class="n">unitary</span><span class="p">(</span><span class="n">circuit21</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m12</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">m21</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">m12</span><span class="p">,</span> <span class="n">m21</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span>


<span class="nd">@value</span><span class="o">.</span><span class="n">value_equality</span>
<span class="k">class</span> <span class="nc">TaggedOperation</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Operation annotated with a set of Tags.</span>

<span class="sd">    These Tags can be used for special processing.  TaggedOperations</span>
<span class="sd">    can be initialized with using Operation.with_tags(tag)</span>
<span class="sd">    or by using TaggedOperation(op, tag).</span>

<span class="sd">    Tags added can be of any type, but they should be Hashable in order</span>
<span class="sd">    to allow equality checking.  If you wish to serialize operations into</span>
<span class="sd">    JSON, you should restrict yourself to only use objects that have a JSON</span>
<span class="sd">    serialization.</span>

<span class="sd">    See Operation.with_tags() for more information on intended usage.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_operation</span><span class="p">:</span> <span class="s1">&#39;cirq.Operation&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">tags</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span> <span class="o">=</span> <span class="n">sub_operation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tags</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">qubits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;cirq.Qid&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="o">.</span><span class="n">qubits</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;cirq.Gate&#39;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="o">.</span><span class="n">gate</span>

    <span class="k">def</span> <span class="nf">with_qubits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">new_qubits</span><span class="p">:</span> <span class="s1">&#39;cirq.Qid&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TaggedOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="o">.</span><span class="n">with_qubits</span><span class="p">(</span><span class="o">*</span><span class="n">new_qubits</span><span class="p">),</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_tags</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_with_measurement_key_mapping_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]):</span>
        <span class="n">sub_op</span> <span class="o">=</span> <span class="n">protocols</span><span class="o">.</span><span class="n">with_measurement_key_mapping</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">,</span> <span class="n">key_map</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sub_op</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">TaggedOperation</span><span class="p">(</span><span class="n">sub_op</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">controlled_by</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">control_qubits</span><span class="p">:</span> <span class="s1">&#39;cirq.Qid&#39;</span><span class="p">,</span>
        <span class="n">control_values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Collection</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;cirq.Operation&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="o">.</span><span class="n">controlled_by</span><span class="p">(</span><span class="o">*</span><span class="n">control_qubits</span><span class="p">,</span> <span class="n">control_values</span><span class="o">=</span><span class="n">control_values</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tags</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns a tuple of the operation&#39;s tags.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tags</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">untagged</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;cirq.Operation&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the underlying operation without any tags.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span>

    <span class="k">def</span> <span class="nf">with_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">new_tags</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;cirq.TaggedOperation&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates a new TaggedOperation with combined tags.</span>

<span class="sd">        Overloads Operation.with_tags to create a new TaggedOperation</span>
<span class="sd">        that has the tags of this operation combined with the new_tags</span>
<span class="sd">        specified as the parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">new_tags</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">TaggedOperation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_tags</span><span class="p">,</span> <span class="o">*</span><span class="n">new_tags</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">tag_repr</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tags</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;cirq.TaggedOperation(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">)</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">tag_repr</span><span class="si">}</span><span class="s1">)&#39;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_value_equality_values_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tags</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_json_dict_</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">sub_operation</span><span class="p">,</span> <span class="n">tags</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sub_operation</span><span class="p">,</span> <span class="o">*</span><span class="n">tags</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_json_dict_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">obj_to_dict_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;sub_operation&#39;</span><span class="p">,</span> <span class="s1">&#39;tags&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_decompose_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;cirq.OP_TREE&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_pauli_expansion_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="o">.</span><span class="n">LinearDict</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">pauli_expansion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply_unitary_</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="s1">&#39;protocols.ApplyUnitaryArgs&#39;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">NotImplementedType</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">apply_unitary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_has_unitary_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">has_unitary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_unitary_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">NotImplementedType</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">unitary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_commutes_</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">atol</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-8</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">NotImplementedType</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">commutes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_has_mixture_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">has_mixture</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_mixture_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">mixture</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_has_kraus_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">has_kraus</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_kraus_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">NotImplementedType</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">kraus</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_measurement_key_names_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractSet</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">measurement_key_names</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_measurement_key_objs_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractSet</span><span class="p">[</span><span class="n">value</span><span class="o">.</span><span class="n">MeasurementKey</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">measurement_key_objs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_measurement_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">sub</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">,</span> <span class="s2">&quot;_is_measurement_&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sub</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sub</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">_is_parameterized_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">is_parameterized</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span>
            <span class="n">protocols</span><span class="o">.</span><span class="n">is_parameterized</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_act_on_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="s1">&#39;cirq.ActOnArgs&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">sub</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">,</span> <span class="s2">&quot;_act_on_&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sub</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sub</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">_parameter_names_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractSet</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">tag_params</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">protocols</span><span class="o">.</span><span class="n">parameter_names</span><span class="p">(</span><span class="n">tag</span><span class="p">)}</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">parameter_names</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">)</span> <span class="o">|</span> <span class="n">tag_params</span>

    <span class="k">def</span> <span class="nf">_resolve_parameters_</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">resolver</span><span class="p">:</span> <span class="s1">&#39;cirq.ParamResolver&#39;</span><span class="p">,</span> <span class="n">recursive</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TaggedOperation&#39;</span><span class="p">:</span>
        <span class="n">resolved_op</span> <span class="o">=</span> <span class="n">protocols</span><span class="o">.</span><span class="n">resolve_parameters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">,</span> <span class="n">resolver</span><span class="p">,</span> <span class="n">recursive</span><span class="p">)</span>
        <span class="n">resolved_tags</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">protocols</span><span class="o">.</span><span class="n">resolve_parameters</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">resolver</span><span class="p">,</span> <span class="n">recursive</span><span class="p">)</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tags</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">TaggedOperation</span><span class="p">(</span><span class="n">resolved_op</span><span class="p">,</span> <span class="o">*</span><span class="n">resolved_tags</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_circuit_diagram_info_</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="s1">&#39;cirq.CircuitDiagramInfoArgs&#39;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;cirq.CircuitDiagramInfo&#39;</span><span class="p">:</span>
        <span class="n">sub_op_info</span> <span class="o">=</span> <span class="n">protocols</span><span class="o">.</span><span class="n">circuit_diagram_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
        <span class="c1"># Add tag to wire symbol if it exists.</span>
        <span class="k">if</span> <span class="n">sub_op_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">NotImplemented</span> <span class="ow">and</span> <span class="n">args</span><span class="o">.</span><span class="n">include_tags</span> <span class="ow">and</span> <span class="n">sub_op_info</span><span class="o">.</span><span class="n">wire_symbols</span><span class="p">:</span>
            <span class="n">sub_op_info</span><span class="o">.</span><span class="n">wire_symbols</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">sub_op_info</span><span class="o">.</span><span class="n">wire_symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tags</span><span class="p">)),</span>
            <span class="p">)</span> <span class="o">+</span> <span class="n">sub_op_info</span><span class="o">.</span><span class="n">wire_symbols</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">sub_op_info</span>

    <span class="k">def</span> <span class="nf">_trace_distance_bound_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">trace_distance_bound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_phase_by_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phase_turns</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">qubit_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;cirq.Operation&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">phase_by</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">,</span> <span class="n">phase_turns</span><span class="p">,</span> <span class="n">qubit_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exponent</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;cirq.Operation&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span> <span class="o">**</span> <span class="n">exponent</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span> <span class="o">*</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span>

    <span class="k">def</span> <span class="nf">_qasm_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="s1">&#39;protocols.QasmArgs&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">qasm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_equal_up_to_global_phase_</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">atol</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-8</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">NotImplementedType</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">equal_up_to_global_phase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub_operation</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span>


<span class="nd">@value</span><span class="o">.</span><span class="n">value_equality</span>
<span class="k">class</span> <span class="nc">_InverseCompositeGate</span><span class="p">(</span><span class="n">Gate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The inverse of a composite gate.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original</span><span class="p">:</span> <span class="n">Gate</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original</span> <span class="o">=</span> <span class="n">original</span>

    <span class="k">def</span> <span class="nf">_qid_shape_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">qid_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">power</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">power</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">power</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">_decompose_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubits</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">protocols</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">protocols</span><span class="o">.</span><span class="n">decompose_once_with_qubits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original</span><span class="p">,</span> <span class="n">qubits</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_has_unitary_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">cirq</span> <span class="kn">import</span> <span class="n">protocols</span><span class="p">,</span> <span class="n">devices</span>

        <span class="n">qubits</span> <span class="o">=</span> <span class="n">devices</span><span class="o">.</span><span class="n">LineQid</span><span class="o">.</span><span class="n">for_gate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">protocols</span><span class="o">.</span><span class="n">has_unitary</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">protocols</span><span class="o">.</span><span class="n">decompose_once_with_qubits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original</span><span class="p">,</span> <span class="n">qubits</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_value_equality_values_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original</span>

    <span class="k">def</span> <span class="nf">_circuit_diagram_info_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="s1">&#39;cirq.CircuitDiagramInfoArgs&#39;</span><span class="p">):</span>
        <span class="n">sub_info</span> <span class="o">=</span> <span class="n">protocols</span><span class="o">.</span><span class="n">circuit_diagram_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">NotImplemented</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sub_info</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="n">sub_info</span><span class="o">.</span><span class="n">exponent</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">sub_info</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_original</span><span class="si">!r}</span><span class="s1">**-1)&#39;</span>


<span class="k">def</span> <span class="nf">_validate_qid_shape</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">qubits</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="s1">&#39;cirq.Qid&#39;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Helper function to validate qubits for gates and operations.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: The operation had qids that don&#39;t match it&#39;s qid shape.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">qid_shape</span> <span class="o">=</span> <span class="n">protocols</span><span class="o">.</span><span class="n">qid_shape</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">qid_shape</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Wrong number of qubits for &lt;</span><span class="si">{!r}</span><span class="s1">&gt;. &#39;</span>
            <span class="s1">&#39;Expected </span><span class="si">{}</span><span class="s1"> qubits but got &lt;</span><span class="si">{!r}</span><span class="s1">&gt;.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">qid_shape</span><span class="p">),</span> <span class="n">qubits</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">qid</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="n">dimension</span> <span class="k">for</span> <span class="n">qid</span><span class="p">,</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">qid_shape</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Wrong shape of qids for &lt;</span><span class="si">{!r}</span><span class="s1">&gt;. &#39;</span>
            <span class="s1">&#39;Expected </span><span class="si">{}</span><span class="s1"> but got </span><span class="si">{}</span><span class="s1"> &lt;</span><span class="si">{!r}</span><span class="s1">&gt;.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">val</span><span class="p">,</span> <span class="n">qid_shape</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">qid</span><span class="o">.</span><span class="n">dimension</span> <span class="k">for</span> <span class="n">qid</span> <span class="ow">in</span> <span class="n">qubits</span><span class="p">),</span> <span class="n">qubits</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">qubits</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;Duplicate qids for &lt;</span><span class="si">{</span><span class="n">val</span><span class="si">!r}</span><span class="s1">&gt;. Expected unique qids but got &lt;</span><span class="si">{</span><span class="n">qubits</span><span class="si">!r}</span><span class="s1">&gt;.&#39;</span>
        <span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Shi-Ning Sun.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>